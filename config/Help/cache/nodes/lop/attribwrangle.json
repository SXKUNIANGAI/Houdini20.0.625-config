{"type": "root", "attrs": {"type": "node", "context": "lop", "internal": "attribwrangle", "icon": "SOP/attribwrangle", "group": "attributes", "since": "17.0", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Attribute Wrangle"], "extent": [0, 22]}, {"type": "summary", "indent": 0, "text": ["Create/edit USD primitive attributes using a VEX snippet."], "extent": [131, 197]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [197, 212], "body": [{"type": "para", "indent": 0, "text": ["This node is similar to the ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle SOP"], "fullpath": "/nodes/sop/attribwrangle.html"}, "."], "extent": [212, 290]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["For each prim selected in the ", {"type": "ui", "text": ["Primitives"]}, " parameter, the node runs the ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippet"], "fullpath": "/vex/snippets.html"}, "."], "extent": [290, 396]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can read current attribute values using ", {"type": "code", "text": ["@name"]}, ", and create/update attribute values by writing to an ", {"type": "code", "text": ["@"]}, " variable with the same name as the attribute."], "extent": [396, 554]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can also use ", {"scheme": null, "value": "/solaris/vex", "type": "link", "text": ["VEX USD functions"], "fullpath": "/solaris/vex.html"}, " to manipulate the primitive."], "extent": [554, 636]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The Bindings tab lets you explicitly map VEX variable names to USD attributes."], "extent": [636, 718], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["This is useful when USD attributes have names that are not valid VEX variable names."], "extent": [718, 810]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["For attributes that don\u2019t exist yet, you can specify an explicit USD type."], "extent": [810, 893]}], "container": true}], "container": true}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Syntax"], "extent": [893, 906], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["VEX snippet"]}, " parameter lets you enter a snippet of ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["VEX code"], "fullpath": "/vex/index.html"}, " to run on the input geometry.\nSee ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippets"], "fullpath": "/vex/snippets.html"}, " for basic information on the syntax available in the snippet parameter.\nSee ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["the VEX chapter"], "fullpath": "/vex/index.html"}, " for general information on the VEX language."], "extent": [16, 299]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Built-in variables"], "extent": [945, 970], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["@primpath"]}, " is the scene graph path of the current prim."], "extent": [970, 1031]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Normally, ", {"type": "code", "text": ["elemnum"]}, " is the index of the current prim in the list of selected prims, and ", {"type": "code", "text": ["numelem"]}, " is the total number of selected prims. However, the meanings of these variables are different when ", {"type": "ui", "text": ["Run on elements of array attributes"]}, " is on."], "extent": [1031, 1278]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The following ", {"type": "q", "text": ["convenience"]}, " built-ins are available as well:"], "extent": [1278, 1342], "body": [{"type": "table", "thead": [{"type": "row", "body": [{"type": "cell", "indent": 4, "text": ["Name "], "role": "th", "extent": [1342, 1354], "container": true}, {"type": "cell", "indent": 8, "text": ["Equivalent to "], "role": "th", "extent": [1354, 1379], "container": true}, {"type": "cell", "indent": 12, "text": ["Content "], "role": "th", "extent": [1379, 1402]}], "divider": false}], "body": [{"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["primname"]}, " "], "role": "td", "extent": [1402, 1419], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["usd_name( 0, @primpath )"]}, " "], "role": "td", "extent": [1419, 1456], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Current prim\u2019s name"], "extent": [1456, 1488]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["primtype"]}, " "], "role": "td", "extent": [1488, 1505], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["usd_typename(0, @primpath)"]}, " "], "role": "td", "extent": [1505, 1544], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Current prim\u2019s schema name"], "extent": [1544, 1583]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["primkind"]}, " "], "role": "td", "extent": [1583, 1600], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["usd_kind(0, @primpath)"]}, " "], "role": "td", "extent": [1600, 1635], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Current prim\u2019s ", {"scheme": null, "value": "/solaris/usd#kinds", "type": "link", "text": ["kind"], "fullpath": "/solaris/usd.html#kinds", "fragment": "#kinds"}], "extent": [1635, 1688]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["primpurpose"]}, " "], "role": "td", "extent": [1688, 1708], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["usd_purpose(0, @primpath)"]}, " "], "role": "td", "extent": [1708, 1746], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Current prim\u2019s ", {"scheme": null, "value": "/solaris/usd#purpose", "type": "link", "text": ["purpose"], "fullpath": "/solaris/usd.html#purpose", "fragment": "#purpose"}], "extent": [1746, 1804]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["primdrawmode"]}, " "], "role": "td", "extent": [1804, 1825], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["usd_drawmode(0, @primpath)"]}, " "], "role": "td", "extent": [1825, 1864], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Current prim\u2019s  draw mode"], "extent": [1864, 1902]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["primactive"]}, " "], "role": "td", "extent": [1902, 1921], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["usd_isactive(0, @primpath)"]}, " "], "role": "td", "extent": [1921, 1960], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": [{"type": "code", "text": ["1"]}, " if current prim is active"], "extent": [1960, 2002]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["primvisible"]}, " "], "role": "td", "extent": [2002, 2022], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["usd_isvisible(0, @primpath)"]}, " "], "role": "td", "extent": [2022, 2062], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": [{"type": "code", "text": ["1"]}, " if primitive is visible"], "extent": [2062, 2103]}]}], "divider": false}]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The prim\u2019s current variant doesn\u2019t have a built-in, but you can get it using a function call:"], "extent": [2103, 2200], "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["usd_variantselection(0, @primpath, \"variant_set_name\")"]}], "extent": [2200, 2263]}], "container": true}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Tips"], "extent": [2263, 2274], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["This node can run the snippet over each prim, or over each element in each array attribute on each prim. See the ", {"type": "ui", "text": ["Run On Elements of Array Attributes"]}, " parameter."], "extent": [2274, 2442]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["When using the sampling parameters on this node, be aware that only the setting of attributes are applied to the USD stage after the first sample is evaluated. Other operations such as the creation of primitives or setting metadata (which cannot vary over time) will only run for the first sample."], "extent": [2442, 2743]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Cooking multiple samples may require cooking other nodes multiple times. If your VEX code refers to a SOP network, for example, that SOP network may be cooked for each time sample. If a LOP node connected to the input of this node is time dependent, this input node will also be recooked for each time sample on this node."], "extent": [2743, 3070]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["In VEX snippets, you can use ", {"type": "code", "text": ["@"]}, " variable names containing colons (", {"type": "code", "text": [":"]}, "). This makes it easier to automatically bind certain USD attribute names (for example ", {"type": "code", "text": ["i@primvars:foo"]}, "). (These names are not normally legal in names in VEX source code. The node automatically encodes these kinds of names when used in a snippet.)"], "extent": [16, 336]}], "container": true}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [3097, 3109], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Sampling Behavior"], "extent": [2196, 2216], "body": [{"type": "para", "indent": 4, "text": ["Cooking this node can generate many USD time samples, rather than just a single time sample at the current time. This can be equivalent to having a ", {"scheme": "Node", "value": "/nodes/lop/cache", "type": "link", "text": ["Cache LOP"], "fullpath": "/nodes/lop/cache.html"}, " following this node, but it will evaluate much faster, and does not cache data from any other nodes. This allows animated data to be authored to USD without introducing a node time dependency which would then cause all following nodes to also be time dependent. This can vastly improve playback performance of some LOP Networks."], "extent": [2216, 2725]}, {"type": "para", "indent": 4, "text": ["In all sampling modes, if a parameter on this node does not vary with time, and does not rely on other time sampled data from the stage, only a single default value will be generated in USD for the corresponding attribute. USD time samples are only generated for parameters that may vary over time."], "extent": [2725, 3029]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Sample Current Frame"], "extent": [3029, 3055], "body": [{"type": "para", "indent": 8, "text": ["A single time sample will be generated for the current time."], "extent": [3055, 3125]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Sample Frame Range If Input Is Not Time Dependent"], "extent": [3125, 3180], "body": [{"type": "para", "indent": 8, "text": ["If the input to this node is time dependent, this node behaves as if it is in ", {"type": "code", "text": ["Sample current frame"]}, " mode. Otherwise it behaves as if it is in ", {"type": "code", "text": ["Sample frame range"]}, " mode."], "extent": [3180, 3359]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Sample Frame Range"], "extent": [3359, 3383], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "ui", "text": ["Start/End/Inc"]}, " parameter is used to generate multiple times at which this node\u2019s parameters are evaluated, and a USD time sample is created for each attribute at each one of these times."], "extent": [3383, 3586]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Start/End/Inc"], "extent": [3586, 3601], "body": [{"type": "para", "indent": 4, "text": ["When the ", {"type": "ui", "text": ["Sampling behavior"]}, " is ", {"type": "code", "text": ["Sample frame range"]}, ", this parameter controls the number and spacing of base time samples to be generated by this node. The default values of this parameter are ", {"type": "code", "text": ["@fstart"]}, ", ", {"type": "code", "text": ["@fend"]}, ", and ", {"type": "code", "text": ["@finc"]}, ". These values correspond to the start, end, and step size of the global Houdini animation settings when interacting with Houdini. When using a ROP node to generate a range of frames, these values correspond to the start, end, and increment values specified on the ROP node being executed. This default ensures that a USD file written to disk will contain time samples for exactly the frame range requested by the ROP (regardless of the Houdini animation settings)."], "extent": [3601, 4297]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Subframe Sampling"], "extent": [56, 79], "body": [{"type": "para", "indent": 8, "text": ["For each primary sample generated by this node, these parameters can cause additional samples to be generated aroudn that primary sample time. This is most often used to ensure that accurate data exists at exactly the camera shutter open and close times, as well as at the primary sample time."], "extent": [79, 382]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Shutter"], "extent": [382, 395], "body": [{"type": "para", "indent": 8, "text": ["Controls the method used to specify the shutter open and close times relative to the primary sample times."], "extent": [395, 511]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["Specify Manually"], "extent": [511, 537], "body": [{"type": "para", "indent": 12, "text": ["The ", {"type": "ui", "text": ["Shutter open/close"]}, " parameter values provide exact offset values relative to the primary sample time."], "extent": [537, 659]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Use Camera Prim"], "extent": [659, 684], "body": [{"type": "para", "indent": 12, "text": ["The ", {"type": "ui", "text": ["Camera prim"]}, " parameter provides the scene graph path of a camera primitive from which the shutter open and close times are extracted to provide the offset values relative to the primary time sample."], "extent": [684, 903]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Shutter Open/Close"], "extent": [903, 927], "body": [{"type": "para", "indent": 8, "text": ["When the ", {"type": "ui", "text": ["Shutter"]}, " mode is ", {"type": "code", "text": ["Specify Manually"]}, ", these two offset values are added to the primary sample time to indicate the shutter open and close times. The open time should be less than or equal to zero, and the close time should be greater than or equal to zero."], "extent": [927, 1204]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Camera Prim"], "extent": [1204, 1221], "body": [{"type": "para", "indent": 8, "text": ["Scene graph path of a camera prim on the input node\u2019s stage. The shutter open and close attribute values are read from this primitive."], "extent": [1221, 1365]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Samples"], "extent": [1365, 1378], "body": [{"type": "para", "indent": 8, "text": ["The number of subframe samples to create for each primary sample. These samples are evenly distributed between the shutter open and close times. Note that such an even distribution may or may not create a sample at exactly the primary sample time."], "extent": [1378, 1635]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Always Include Frame Sample"], "extent": [1635, 1668], "body": [{"type": "para", "indent": 8, "text": ["Enable this option to force a sample to be created at exactly the primary sample time. If the ", {"type": "ui", "text": ["Samples"]}, " values together with the shutter open and close times already place a sample at the primary sample time, turning on this option will have no effect. Otherwise, this option will cause an addition sample to be added. This means that the actual number of samples per primary sample may in fact be one more than the number specified in the ", {"type": "ui", "text": ["Samples"]}, " parameter."], "extent": [1668, 2143]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Primitives"], "extent": [16, 28], "body": [{"type": "para", "indent": 4, "text": ["The primitive(s) the node should operate on. You can drag primitives from the scene graph tree pane into this textbox to add their paths, or click the ", {"scheme": "Icon", "value": "BUTTONS/reselect", "type": "link", "text": "", "fullpath": "/nodes/lop/BUTTONS/reselect.html"}, " Reselect button beside the text box to select the primitives in the viewer, or ", {"keys": ["Ctrl"], "type": "keys", "text": null}, "-click the Reselect button to choose prims from a pop-up tree window. You can also use ", {"scheme": null, "value": "/solaris/pattern", "type": "link", "text": ["primitive patterns"], "fullpath": "/solaris/pattern.html"}, " for advanced matching, including matching all prims in a collection (using ", {"type": "code", "text": ["/path/to/prim.collection:", {"type": "var", "text": ["name"]}]}, ")."], "extent": [50, 554]}], "container": true, "attrs": {"id": "primpattern"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Allow Instance Proxy Primitives"], "extent": [3217, 3250], "body": [{"type": "para", "indent": 4, "text": ["When this is on, the pattern in the ", {"type": "ui", "text": ["Primitives"]}, " parameter will be allowed to match instance proxy primitives (instanced ancestors of a primitive marked as instanceable). Since instance proxy primitives cannot be directly modified in USD, this mode is primarily used to allow the VEX code to pull data from the instance proxy primitives, and apply values to some non-instanced ancestor primitive."], "extent": [3250, 3654]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Run On Elements of Array Attributes"], "extent": [3654, 3691], "body": [{"type": "para", "indent": 4, "text": ["When this is on, the node evaluates the snippet ", {"type": "strong", "text": ["for each array element"]}, " of array attributes, on each prim. In this mode, the built-in ", {"type": "code", "text": ["elemnum"]}, " refers to the array index, and ", {"type": "code", "text": ["numelem"]}, " refers to the length of the ", {"type": "em", "text": ["largest"]}, " array. (When this is off, array attributes are available in the snippet as array-type variables.)"], "extent": [3691, 4018]}, {"type": "para", "indent": 4, "text": ["If some array attributes have shorter length, their elements are padded with the last element."], "extent": [4018, 4118]}, {"type": "para", "indent": 4, "text": ["This mode may be useful for running over geometry-related attributes such as ", {"type": "code", "text": ["points"]}, "."], "extent": [4118, 4211]}], "container": true, "role": "item"}], "container": true}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Code"], "extent": [4211, 4222], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Vexpression"], "extent": [4222, 4236], "body": [{"type": "para", "indent": 4, "text": ["In the snippet, the path to the current prim is available as ", {"type": "code", "text": ["@primpath"]}, ". You can read current attribute values using ", {"type": "code", "text": ["@", {"type": "var", "text": ["name"]}]}, ", and create/update attribute values by writing to variables with the same name as the attribute. You can also use ", {"scheme": null, "value": "/solaris/vex", "type": "link", "text": ["VEX USD functions"], "fullpath": "/solaris/vex.html"}, " to manipulate the primitive. See ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippets"], "fullpath": "/vex/snippets.html"}, " for more information."], "extent": [4236, 4602]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attributes to Create"], "extent": [4602, 4624], "body": [{"type": "para", "indent": 4, "text": ["When the snippet creates a new variable, only create a corresponding attribute if the variable name matches this pattern. The default is ", {"type": "code", "text": ["*"]}, ", which creates an attribute from any VEX variable created in the snippet."], "extent": [4624, 4844]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enforce Prototypes"], "extent": [4844, 4864], "body": [{"type": "para", "indent": 4, "text": ["Automatic creation of attributes from ", {"type": "code", "text": ["@"]}, " variables is convenience, but there\u2019s a risk a type will bind or create the wrong attribute. When this is on, binding only works if you ", {"scheme": null, "value": "/vex/snippets#declare", "type": "link", "text": ["explicitly declare"], "fullpath": "/vex/snippets.html#declare", "fragment": "#declare"}, " the ", {"type": "code", "text": ["@"]}, " variable before use."], "extent": [4864, 5120]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Bindings"], "extent": [5120, 5135], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Autobind by Name"], "extent": [5135, 5154], "body": [{"type": "para", "indent": 4, "text": ["Automatically create ", {"type": "code", "text": ["@"]}, " variables corresponding to existing attributes (default is on). If this is off, only attributes explicitly bound using the multi-parm below are available as ", {"type": "code", "text": ["@"]}, " variables in the snippet."], "extent": [5154, 5371]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number of Bindings"], "extent": [5371, 5391], "body": [{"type": "para", "indent": 4, "text": ["The number of USD attributes to bind to VEX variables."], "extent": [5410, 5470]}], "container": true, "attrs": {"id": "bindings"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attribute Name"], "extent": [5470, 5486], "body": [{"type": "para", "indent": 4, "text": ["The name of the USD attribute to bind to a VEX variable. Note that this attribute does not need to exist yet. You can bind it to a VEX variable, and if the VEX writes to the variable, the node will create the attribute."], "extent": [5507, 5732]}], "container": true, "attrs": {"id": "bindattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attribute Type"], "extent": [5732, 5748], "body": [{"type": "para", "indent": 4, "text": ["The USD datatype of the attribute. You should usually leave this set to ", {"type": "code", "text": ["Auto"]}, ", so the node will use the known type of an existing attribute. If you are going to create the attribute, and node doesn\u2019t translate the VEX type into the correct USD type (for example, it becomes ", {"type": "code", "text": ["string"]}, " but you want a ", {"type": "code", "text": ["token"]}, "), you can change this to the type you want."], "extent": [5773, 6129]}], "container": true, "attrs": {"id": "bindattribtype"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEX Parameter"], "extent": [6129, 6144], "body": [{"type": "para", "indent": 4, "text": ["The name of the VEX parameter bound to the attribute."], "extent": [6163, 6226]}], "container": true, "attrs": {"id": "bindparm"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Evaluation Node Path"], "extent": [6226, 6248], "body": [{"type": "para", "indent": 4, "text": ["Certain VEX functions, like ", {"type": "code", "text": ["ch()"]}, ", evaluate parameters on this node.\n    In some cases you want these functions to be relative to a different node (for example, with nodes inside a digital asset, you often want to evaluate functions relative to the parent asset). This is a relative node path to the node to use as ", {"type": "q", "text": ["the current node"]}, " in the program."], "extent": [6270, 6626]}], "container": true, "attrs": {"id": "vex_cwdpath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Export Parameters"], "extent": [6626, 6645], "body": [{"type": "para", "indent": 4, "text": ["When a VEX parameter is exported, the bound attribute will be\n    created if it doesn\u2019t exist. This pattern can be used to override\n    this option to avoid writing to or creating certain attributes.  \n    The pattern matches the VEX parameter, not the bound attribute. \n    The attribute will still be bound for reading."], "extent": [6645, 6973]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}], "title": ["Attribute Wrangle"], "summary": ["Create/edit USD primitive attributes using a VEX snippet."], "included": ["/nodes/lop/_primpattern", "/nodes/lop/_sampling", "/nodes/lop/_snippet_token", "/nodes/sop/wrangle_syntax"]}